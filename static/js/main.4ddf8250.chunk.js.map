{"version":3,"sources":["index.js"],"names":["Square","nextProps","nextState","this","props","value","className","onClick","onMouseEnter","icon","faFire","onMouseDown","faRocket","faGlobeAmericas","faMoneyBill","React","Component","Algorithms","i","href","faCaretSquareDown","renderAlgorithm","Mazes_Patterns","renderMazes","Bombs","VisualizeAlgorithm","algoChoice","ClearBoard","ClearWalls_Weights","ClearPath","pathClearing","SpeedOfAlgorithm","speedName","chooseSpeed","Tutorial","handleTutorialClick","e","node","contains","target","handleClickOutside","handleWindowOpen","bind","handleWindowClose","state","closeWindow","document","addEventListener","removeEventListener","setState","classes","ref","Board","isTableRendered","j","squares","width","height","row","push","renderSquare","key","Game","handleMouseDown","handleMouseUp","handleMouseEnter","handleClick","handleAlgorithmClick","handleMazes_PatternsClick","handleAddBombClick","handleVisualizeAlgorithmClick","handleClearBoardClick","handleClearWalls_WeightsClick","handleClearPathClick","handleSpeedClick","updatePredicate","handleMouseDownSquare","handleMouseUpSquare","x","Array","fill","isMouseDown","defaultStartY","defaultStartX","defaultEndY","defaultEndX","startY","startX","endY","endX","defaultWayPointY","defaultWayPointX","wayPointY","wayPointX","wayPointAdded","firstDidMount","speed","dragStart","dragEnd","dragWayPoint","optimalPath","spaceSearched","prevNodesPoint","algorithmRunning","window","aspectRatio","innerWidth","screen","slice","Math","floor","yStart","xStart","grid","y","isHoriz","prevLine","count","wy","random","wx","py","px","choice","setTimeout","timeoutTrigger","height1","recursiveDivision","width1","timesCalled","ceil","temp","flag","tempGrid","currentX","currentY","val","isWayPointAdded","arr","aStarAlgorithm","length","orientation","createMazeBorder","recursiveDivisionVertSkew","recursiveDivisionHorizSkew","basicRandMaze","basicWeightMaze","simpleStairPattern","searchSpace","coords","getX_Y","pathCost","visitedNodes","Map","expandNodes","tempCost","abs","expandNodesCost","foundGoal","moreNodesToExpand","tempKey","getKey","tempPath","tempValue","currentValue","goalKey","set","returnCurrentCoords","listOfKeys","smallestCost","totalOptimalPath","fireIcon","space","pop","shift","get","has","apply","frontierNodes","visualizeAlgorithmsAnimation","isAlgorithmRunning","onMouseUp","column","binaryInsert","array","m","l","r","splice","xFlag","yFlag","yVal","xVal","costEast","oldCost_Path","unshift","tempArr","oldTempKey","oldVisitedValues","newVisitedValues","isArray","valPassed","temp1","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.4ddf8250.chunk.js","sourcesContent":["import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { faRocket } from \"@fortawesome/free-solid-svg-icons\";\r\nimport { faFire } from \"@fortawesome/free-solid-svg-icons\";\r\nimport { faGlobeAmericas } from \"@fortawesome/free-solid-svg-icons\";\r\nimport { faCaretSquareDown } from \"@fortawesome/free-solid-svg-icons\";\r\nimport { faMoneyBill } from \"@fortawesome/free-solid-svg-icons\";\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport './index.css';\r\n\r\n//function Square(props) {\r\n\r\nclass Square extends React.Component{\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    if (this.props.value === nextProps.value) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n  render(){\r\n\r\n  var className = (this.props.value === 0) ? \"white\" : \"black\";//\"square blueVis\";\r\n  if(this.props.value === 0 || this.props.value === 1){\r\n  return (\r\n    /*An opening that can be passed through*/\r\n    <div className={className} onClick={this.props.onClick} onMouseEnter = {this.props.onMouseEnter}>\r\n      </div>\r\n  );\r\n}\r\n\r\nelse if(this.props.value === 2){\r\n  /*an obstruction that can passed through*/\r\n  return (\r\n  <div className=\"white\" onClick={this.props.onClick} onMouseEnter = {this.props.onMouseEnter}>\r\n  <FontAwesomeIcon  className = \"nodeStretch iconsFire fa-sm icons\" icon={faFire} />\r\n\r\n  </div>\r\n);\r\n}\r\nelse if(this.props.value === 3){\r\n  //The starting point\r\n  return(\r\n    <div className=\"white\"  onMouseEnter = {this.props.onMouseEnter}  onMouseDown = {this.props.onMouseDown}>\r\n      <FontAwesomeIcon className = \"nodesStretch icons\"icon={faRocket} />\r\n      </div>\r\n  );\r\n}\r\nelse if(this.props.value === 4){\r\n  //The Ending point\r\n  return(\r\n    <div className=\"white\" onMouseEnter = {this.props.onMouseEnter}  onMouseDown = {this.props.onMouseDown}>\r\n      <FontAwesomeIcon className = \"nodesStretch fa-sm icons\" icon={faGlobeAmericas} />\r\n      </div>\r\n  );\r\n\r\n}\r\nelse if(this.props.value === 5){\r\n  //Teleportation\r\n  return(\r\n    <div className=\"white\" onClick={this.props.onClick} onMouseEnter = {this.props.onMouseEnter}>\r\n      <FontAwesomeIcon className = \"fa-sm icons\" icon={faGlobeAmericas} />\r\n      </div>\r\n  );\r\n\r\n}\r\nelse if(this.props.value === 6){\r\n  //Space Searched\r\n  return(\r\n    <div className=\"blue\" onClick={this.props.onClick} onMouseEnter = {this.props.onMouseEnter}>\r\n\r\n      </div>\r\n  );\r\n\r\n}\r\n\r\nelse if(this.props.value === 7){\r\n  //Optimal Route\r\n    return(\r\n      <div className=\"orange\" onClick={this.props.onClick} onMouseEnter = {this.props.onMouseEnter}>\r\n          </div>\r\n        );\r\n      }\r\n  else if(this.props.value === 8){\r\n    //Money middle destination\r\n    return(\r\n      <div className=\"white\" onMouseDown = {this.props.onMouseDown} onMouseEnter = {this.props.onMouseEnter}>\r\n        <FontAwesomeIcon className = \"fa-sm icons greenMoney nodesStretch\" icon={faMoneyBill} />\r\n        </div>\r\n    );\r\n    }\r\n}\r\n}\r\n\r\nclass Algorithms extends React.Component{\r\n\r\n\r\n  renderAlgorithm(i){\r\n    return (<button onClick = {() => this.props.onClick(i)}>\r\n    {i}\r\n    </button>\r\n  );\r\n  //{this.renderAlgorithm(\"Swarm Algorithm\")}\r\n  //{this.renderAlgorithm(\"Convergent Swarm Algorithm\")}\r\n  //{this.renderAlgorithm(\"Bidirectional Swarm Algorithm\")}\r\n  }\r\n\r\n  render(){\r\n    return(\r\n      <li className=\"dropdown leftPadding\">\r\n        <a href=\"javascript:void(0)\" className=\"dropbtn\">Algorithms\r\n          <FontAwesomeIcon  className = \"iconPadding fa-sm\" icon={faCaretSquareDown} />\r\n        </a>\r\n        <div className=\"dropdown-content\">\r\n          {this.renderAlgorithm(\"A* Search\")}\r\n          {this.renderAlgorithm(\"Dijikstra's Algorithm\")}\r\n          {this.renderAlgorithm(\"Greedy Best-first Search\")}\r\n          {this.renderAlgorithm(\"Breadth-first Search\")}\r\n          {this.renderAlgorithm(\"Depth-first Search\")}\r\n        </div>\r\n      </li>\r\n    );\r\n  }\r\n}\r\nclass Mazes_Patterns extends React.Component{\r\n\r\n  renderMazes(i){\r\n    return (<button onClick = {() => this.props.onClick(i)}>\r\n    {i}\r\n    </button>\r\n  );\r\n\r\n  }\r\n\r\n  render(){\r\n    return(\r\n      <li className=\"dropdown\">\r\n        <a href=\"javascript:void(0)\" className=\"dropbtn\">Mazes & Patterns\r\n        <FontAwesomeIcon  className = \"iconPadding fa-sm\" icon={faCaretSquareDown} /></a>\r\n        <div className=\"dropdown-content\">\r\n        {this.renderMazes(\"Create Border\")}\r\n        {this.renderMazes(\"Recursive Division\")}\r\n        {this.renderMazes(\"Recursive Division (vertical skew)\")}\r\n        {this.renderMazes(\"Recursive Division (horizontal skew)\")}\r\n        {this.renderMazes(\"Basic Random Maze\")}\r\n        {this.renderMazes(\"Basic Weight Maze\")}\r\n        {this.renderMazes(\"Simple Stair Pattern\")}\r\n        </div>\r\n      </li>\r\n    );\r\n  }\r\n}\r\nclass Bombs extends React.Component{\r\n\r\n  render(){\r\n    return(\r\n      <li><button onClick = {this.props.onClick}>Add Money</button></li>\r\n    );\r\n  }\r\n}\r\nclass VisualizeAlgorithm extends React.Component{\r\n\r\n  render(){\r\n    return(\r\n      <li><button onClick = {() => this.props.onClick()}>Start {this.props.algoChoice}!</button></li>\r\n    );\r\n  }\r\n}\r\nclass ClearBoard extends React.Component{\r\n\r\n  render(){\r\n    return(\r\n      <li><button onClick = {this.props.onClick}>Reset Board</button></li>\r\n    );\r\n  }\r\n}\r\nclass ClearWalls_Weights extends React.Component{\r\n\r\n  render(){\r\n    return(\r\n      <li><button onClick = {this.props.onClick}>Clear Walls & Fire</button></li>\r\n    );\r\n  }\r\n}\r\nclass ClearPath extends React.Component{\r\n  pathClearing(i){\r\n    return(\r\n      <button onClick = {() => this.props.onClick(i)}>Clear Path</button>\r\n    );\r\n  }\r\n  render(){\r\n    return(\r\n      <li>\r\n      {this.pathClearing(false)}\r\n      </li>\r\n    );\r\n  }\r\n}\r\nclass SpeedOfAlgorithm extends React.Component{\r\n  chooseSpeed(i){\r\n    return (<button onClick = {() => this.props.onClick(i)}>\r\n    {i}\r\n    </button>\r\n  );\r\n\r\n  }\r\n  render(){\r\n    return(\r\n      <li className=\"dropdown\">\r\n        <a href=\"javascript:void(0)\" className=\"dropbtn\">Speed: {this.props.speedName}\r\n        <FontAwesomeIcon  className = \"iconPadding fa-sm\" icon={faCaretSquareDown} /></a>\r\n        <div className=\"dropdown-content\">\r\n          {this.chooseSpeed(\"Fast\")}\r\n          {this.chooseSpeed(\"Average\")}\r\n          {this.chooseSpeed(\"Slow\")}\r\n        </div>\r\n      </li>\r\n    );\r\n  }\r\n}\r\nclass Tutorial extends React.Component{\r\n  constructor(props){\r\n    super(props);\r\n    this.handleWindowOpen = this.handleWindowOpen.bind(this);\r\n    this.handleWindowClose = this.handleWindowClose.bind(this);\r\n    this.state = {\r\n      closeWindow: true,\r\n    };\r\n  }\r\n  componentDidMount(){\r\n    document.addEventListener('mousedown', this.handleTutorialClick, false); //add event listener to entire document\r\n  }\r\n  componentWillUnmount(){\r\n    document.removeEventListener('mousedown', this.handleTutorialClick, false);\r\n  }\r\n  handleTutorialClick = (e) => {\r\n    if(this.node.contains(e.target)){\r\n      return; //click is inside the popup window\r\n    }\r\n    this.handleClickOutside();\r\n  }\r\n  handleClickOutside(){\r\n    this.setState({closeWindow: true});\r\n  }\r\n  handleWindowOpen(){\r\n    this.setState({closeWindow: false});\r\n  }\r\n  handleWindowClose(){\r\n    this.setState({closeWindow: true});\r\n  }\r\n  render(){\r\n    const closeWindow = this.state.closeWindow;\r\n    var classes = (closeWindow) ? \"popUpWindowClose\" : \"popUpWindowOpen\";\r\n    return(\r\n      <>\r\n\r\n      <li onClick = {this.handleWindowOpen}><button>Tutorial</button></li>\r\n      <div className = {classes} ref={node => this.node = node}>\r\n        <button onClick = {this.handleWindowClose}>X</button>\r\n        <h3>This program will simulate various Pathfinding Algorithms\r\n          <FontAwesomeIcon className = \"nodesStretch icons smallerLeftPadding\"icon={faRocket} />\r\n        </h3>\r\n        <ol className = \"liFormat\">\r\n        <li>Start, Waypoint, and Destination are all draggable! Feel free to position them where you like</li>\r\n        <li>Choose an algorithm from the drop down menu</li>\r\n        <li> Choose a maze or pattern from the drop down menu or create your own by clicking and dragging the mouse across the grid</li>\r\n        <li> The Add Money waypoint will add a middle destination for the rocket to reach, before heading to its home planet</li>\r\n        <li>Choose a speed for the algorithm and create maze to run at, from the speed drop down menu</li>\r\n        <li>Click the Start button to visualize the algorithm</li>\r\n        <li>After the algorithm has finished running, you can drag the rocket, money, or planet around for realtime visualization of the chosen algorithm</li>\r\n        <li>Thanks for checking out my program! I hope you enjoy it. From Jade Richardson.</li>\r\n        </ol>\r\n        <h4>Tips and Tricks\r\n        <FontAwesomeIcon  className = \"nodeStretch iconsFire fa-sm icons smallerLeftPadding\" icon={faFire} /></h4>\r\n        <p>A*, Dijikstra, and Breadth First search will find the shortest path. Depth First and Greedy will find a path..</p>\r\n        <p>Use Clear Path button to reset algorithms, clear searchspace, and path found.</p>\r\n        <p>The rocket can go through fire, but it is expensive and the rocket would prefer to avoid that</p>\r\n        <p>An empty square grid is + 1 path cost, while fire is + 15 path cost</p>\r\n        <p>Clear path will reset the search space and the optimal path to the destination. It will also reset realtime visualization of the algorithm</p>\r\n        <p>Reset Board will reset the start and end point back to their original positions and will clear walls, weights, paths, and realtime visualization</p>\r\n        <p>Since the program  is run aschronously, it is possible to run two algorithms or mazes at the same time. This can have an impact on performance. Go ahead and refresh the page if the program runs slowly.</p>\r\n\r\n        <p></p>\r\n      </div>\r\n    </>\r\n\r\n    );\r\n  }\r\n}\r\n\r\nclass Board extends React.Component {\r\n  constructor(props){\r\n    super(props);\r\n    let squares = [];\r\n    this.state = {\r\n      isTableRendered: false,\r\n    };\r\n\r\n  }\r\n\r\n\r\n  renderSquare(i,j) {\r\n\r\n    return <Square value = {this.props.squares[i][j]}\r\n    /*This might slow down performance*/\r\n    onClick={() => this.props.onClick(i,j)}\r\n    onMouseEnter={() => this.props.onMouseEnter(i,j)}\r\n    onMouseDown = {() => this.props.onMouseDown(i,j)} //for handling dragging start or end\r\n\r\n    />;\r\n  }\r\n\r\n\r\n  render() {\r\n    const width = this.props.width;\r\n    const height = this.props.height;\r\n    let squares = [];\r\n    for(let i=0; i < height; ++i) {\r\n        let row = [];\r\n        for(let j=0; j<width; ++j) {\r\n          row.push(this.renderSquare(i,j));\r\n        }\r\n  squares.push(<div key={i} className=\"board-row\">{row}</div>);\r\n}\r\n\r\n    return (\r\n      <div>{squares}</div>\r\n  );\r\n  }\r\n}\r\n\r\nclass Game extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseUp = this.handleMouseUp.bind(this);\r\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n    this.handleClick = this.handleClick.bind(this);\r\n    this.handleAlgorithmClick = this.handleAlgorithmClick.bind(this);\r\n    this.handleMazes_PatternsClick = this.handleMazes_PatternsClick.bind(this);\r\n    this.handleAddBombClick = this.handleAddBombClick.bind(this);\r\n    this.handleVisualizeAlgorithmClick = this.handleVisualizeAlgorithmClick.bind(this);\r\n    this.handleClearBoardClick = this.handleClearBoardClick.bind(this);\r\n    this.handleClearWalls_WeightsClick = this.handleClearWalls_WeightsClick.bind(this);\r\n    this.handleClearPathClick = this.handleClearPathClick.bind(this);\r\n    this.handleSpeedClick = this.handleSpeedClick.bind(this);\r\n    this.updatePredicate = this.updatePredicate.bind(this);\r\n    this.handleMouseDownSquare = this.handleMouseDownSquare.bind(this);\r\n    this.handleMouseUpSquare = this.handleMouseUpSquare.bind(this);\r\n    let x = Array(40).fill(null);\r\n    for(let i = 0; i < 40; i++){\r\n      x[i] = Array(100).fill(0);\r\n    }\r\n    let startY = 19;\r\n    let startX = 40;\r\n    let endY = 19;\r\n    let endX = 75;\r\n    x[startY][startX] = 3; //set Default starting point\r\n    x[endY][endX] = 4; //set Default starting point\r\n    this.state = {\r\n      squares: x,\r\n      isMouseDown: false,\r\n      algoChoice: \"\",\r\n      defaultStartY: startY,\r\n      defaultStartX: startX,\r\n      defaultEndY: endY,\r\n      defaultEndX: endX,\r\n      startY: startY,\r\n      startX: startX,\r\n      endY: endY,\r\n      endX: endX,\r\n      defaultWayPointY: 15,\r\n      defaultWayPointX: 25,\r\n      wayPointY: 15,\r\n      wayPointX: 25,\r\n      wayPointAdded: false,\r\n      height: 40,\r\n      width: 100,\r\n      firstDidMount: false,\r\n      speed: 25,\r\n      speedName: \"Fast\",\r\n      dragStart: false,\r\n      dragEnd: false,\r\n      dragWayPoint: false,\r\n      optimalPath:[],\r\n      spaceSearched: [],\r\n      prevNodesPoint: [],\r\n      algorithmRunning: false, //set true if algorithm has ran without clearing: I.E clear board, clear walls and weights, clear path. Algorithm will update optimal path and search space when start, waypoint, or end is moved\r\n      //mazeChoice: \"\",\r\n    };\r\n  }\r\n  componentDidMount(){\r\n    this.updatePredicate();\r\n    window.addEventListener(\"resize\", this.updatePredicate);\r\n  }\r\n  componentWillUnmount(){\r\n    window.removeEventListener(\"resize\", this.updatePredicate);\r\n  }\r\n\r\n  updatePredicate(){\r\n  let firstDidMount = this.state.firstDidMount;\r\n  const widthPx = window.innerWidth; //returns width of the viewport\r\n  const heightPx = window.screen.height; //returns height of the screen\r\n  const aspectRatio = (widthPx / heightPx);\r\n  let endX = this.state.endX;\r\n  let startX = this.state.startX;\r\n  let width = 100; //number of squares rendered in columns across the screen\r\n  if(!firstDidMount){\r\n    let squares = this.state.squares.slice();\r\n    if (aspectRatio <= 1){ //aspect ratio 8/8\r\n      width = 50;\r\n      endX = Math.floor((endX / 2));\r\n      startX = Math.floor((startX / 2));\r\n      let squares = this.state.squares.slice();\r\n      squares[this.state.startY][startX] = 3; //set start to new place\r\n      squares[this.state.startY][this.state.startX] = 0; //set old start to 0\r\n      squares[this.state.endY][endX] = 4; //set destination to new place\r\n      squares[this.state.endY][this.state.endX] = 0; //set old destination to 0\r\n      this.setState({\r\n        width: width,\r\n        firstDidMount: firstDidMount,\r\n        endX: endX,\r\n        startX: startX,\r\n        defaultStartX: startX,\r\n        defaultEndX: endX,\r\n        squares: squares,\r\n      });\r\n    }\r\n    if (aspectRatio > 1){ //aspect ration 16/8\r\n        width = 100;\r\n      }\r\n\r\n      firstDidMount = true;\r\n  //aspect ratio is width/ height i.e 1920/1080 = 16:9 aspect ratio\r\n    this.setState({\r\n      firstDidMount: firstDidMount, // component mounted for the first time, set to true\r\n    });\r\n    //this.createMazeBorder(width);\r\n  }\r\n}\r\n  createMazeBorder(width){\r\n  const yStart = this.state.startY;\r\n  const xStart = this.state.startX;\r\n  const endY = this.state.endY;\r\n  const endX = this.state.endX;\r\n  const wayPointY = this.state.wayPointY;\r\n  const wayPointX = this.state.wayPointX;\r\n  //const width = this.state.width;\r\n  const height = this.state.height;\r\n  let squares = this.state.squares.slice();\r\n  for (let x = 0; x < width; x++){\r\n  if((squares[0][x] !== 3) || (squares[0][x] !== 4)){\r\n  squares[0][x] = 1;\r\n}\r\n\r\n  this.setState({squares: squares,});\r\n}\r\n\r\n  for (let x = 0; x < height; x++){\r\n    if(squares[x][0] !== 3 || squares[x][0] !== 4){\r\n      squares[x][0] = 1;\r\n    }\r\n}\r\n  for (let x = 0; x < width; x++){\r\n    if(squares[height - 1][x] !== 3 || squares[height - 1][x] !== 4){\r\n      squares[height - 1][x] = 1;\r\n    }\r\n}\r\n  for (let x = 0; x < height; x++){\r\n    if(squares[x][(width - 1)] !== 3 || squares[x][(width - 1)] !== 4){\r\n      squares[x][(width - 1)] = 1;\r\n    }\r\n}\r\nif(this.state.wayPointAdded){\r\n  squares[wayPointY][wayPointX] = 8;\r\n}\r\nsquares[yStart][xStart] = 3;\r\nsquares[endY][endX] = 4;\r\nthis.setState({\r\n  squares: squares,\r\n});\r\n}\r\n  recursiveDivision(grid, x, y, width, height, isHoriz,prevLine, count){\r\n  const yStart = this.state.startY;\r\n  const xStart = this.state.startX;\r\n  const endY = this.state.endY;\r\n  const endX = this.state.endX;\r\n\r\n  const speed = Math.floor(this.state.speed / 3); //wait a third of the time before drawing next square\r\n\r\n  grid[yStart][xStart] = 3;\r\n  grid[endY][endX] = 4;\r\n\r\n  if(width < 4 || height < 4){\r\n    return count;\r\n  }\r\n\r\n\r\nvar wy = y + Math.floor(Math.random() * (height - 4));\r\nvar wx = x + Math.floor(Math.random() * (width - 4));\r\nvar py = y + Math.floor(Math.random() * (height - 2)) + 1;\r\nvar px = x + Math.floor(Math.random() * (width - 2)) + 1;\r\nlet choice = Math.floor((Math.random() * 2)); //random number 0 or 1\r\nlet val = 1;\r\n\r\nif(width < 6){\r\n  wy = y + 1;\r\n}\r\nif(height < 6){\r\n  wx = x + 1;\r\n}\r\n/*Openings are on  even cells only*/\r\nif((px % 2) == 1){\r\n  if(choice === 1){\r\n  px +=1;\r\n}\r\nelse {\r\n  px -=1;\r\n}\r\nif(px === 0){\r\n  px += 2;\r\n}\r\nif(px === (width - 1)){\r\n  px -= 2;\r\n}\r\n}\r\nif((py % 2) == 1){\r\n  if(choice === 1){\r\n  py +=1;\r\n  }\r\n  else{\r\n    py -=1;\r\n  }\r\n  if(py === (height - 1)){\r\n    py -= 2;\r\n  }\r\n  if(py === 0){\r\n    py +=2;\r\n  }\r\n}\r\n/* Walls are on odd cells only*/\r\nif((wx % 2) == 0){\r\n  wx +=1;\r\n}\r\nif((wy % 2) == 0){\r\n  wy +=1;\r\n}\r\nif(wy == 1){\r\n  wy = 0;\r\n}\r\nif(wx == 1){\r\n  wx = 0;\r\n}\r\n\r\n\r\n\r\nif(isHoriz){\r\n\r\n  for(let j = x; j < (width + x); j++){\r\n    if(j !== px && grid[wy][j] !== 3 && grid[wy][j] !== 4 && grid[wy][j] !== 8){\r\n    //grid[wy][j] = 1;\r\n    setTimeout(this.timeoutTrigger.bind(this), speed * count,grid,j,wy,val); //val is 1 i.e maze wall\r\n    count += 1;\r\n    }\r\n  }\r\n  if(wy !== 0 && wy !== (height - 1)){\r\n    setTimeout(this.timeoutTrigger.bind(this), speed * count,grid,px,wy,0); //val is 1 i.e maze wall\r\n  }\r\n  //|| wy === 0 || wy === (height - 1)\r\n  this.setState({\r\n    squares: grid,\r\n  });\r\n\r\n  isHoriz = !isHoriz;\r\n  var height1 = wy - y + 1;\r\n  count = this.recursiveDivision(grid,x,y,width,height1, isHoriz, py, count); //Upper quadrant to be divided by vert line\r\n  count = this.recursiveDivision(grid,x,wy + 1,width,(height - height1), isHoriz, py, count); //lower quadrant to be divided by vert line\r\n}else{\r\n\r\n  for(let j = y; j < (height + y); j++){\r\n    if((j !== py) && grid[j][wx] !== 3 && grid[j][wx] !== 4 && grid[wy][j] !== 8){\r\n    //grid[j][wx] = 1;\r\n    setTimeout(this.timeoutTrigger.bind(this), speed * count,grid,wx,j,val); //val is 1 i.e maze wall\r\n    count += 1;\r\n    }\r\n  }\r\n  if(wx !== 0 || wx !== (width - 1)){\r\n    setTimeout(this.timeoutTrigger.bind(this), speed * count,grid,wx,py,0); //val is 1 i.e maze wall\r\n  }\r\n  this.setState({\r\n    squares: grid,\r\n  });\r\n\r\n  isHoriz = !isHoriz;\r\n  var width1 = wx - x + 1;\r\n  count = this.recursiveDivision(grid,x,y,width1,height, isHoriz, px, count); //Left quadrant to be divided by horizontal line\r\n  count = this.recursiveDivision(grid,wx + 1,y,(width - width1),height, isHoriz, px, count); //Right quadrant to be divided by horizontal line\r\n}\r\nreturn count;\r\n\r\n}\r\n  recursiveDivisionVertSkew(grid, x, y, width, height, isHoriz,timesCalled){\r\n  const yStart = this.state.startY;\r\n  const xStart = this.state.startX;\r\n  const endY = this.state.endY;\r\n  const endX = this.state.endX;\r\n  const wayPointX = this.state.wayPointX;\r\n  const wayPointY = this.state.wayPointY;\r\n\r\n  let count = 0;\r\n  let wx = (width === 50) ? (width / 5) - 1 : (width / 10) - 1; //if width is 50 or 100\r\n  let py = 0;\r\n  let width1 = 10;\r\n  while(wx < (width - 1)){\r\n\r\n  py = y + Math.floor(Math.random() * (height - 2)) + 1;\r\n  if((py % 2) == 1){\r\n    py +=1;\r\n    if(py == (height - 1)){\r\n      py -= 2;\r\n    }\r\n  }\r\n  for(let j = y; j < (height + y); j++){ //draw vertical lines that divide the total grid by 5 or 10 depending on the width\r\n    grid[j][wx] = 1;\r\n  }\r\n  grid[py][wx] = 0;\r\n  grid[yStart][xStart] = 3;\r\n  grid[endY][endX] = 4;\r\n  isHoriz = true;\r\n  width1 = wx - x + 1;\r\n  wx += 10;\r\n  if(this.state.wayPointAdded){\r\n    grid[wayPointY][wayPointX] = 8;\r\n  }\r\n  this.setState({\r\n    squares: grid,\r\n  });\r\n  count = this.recursiveDivision(grid,x,y,width1,height, isHoriz, count); //Left quadrant to be divided by horizontal line\r\n\r\n  x += 10;\r\n}\r\nthis.recursiveDivision(grid,x,y,width1,height, isHoriz, count); //Left quadrant to be divided by horizontal line\r\n}\r\n  recursiveDivisionHorizSkew(grid, x, y, width, height, isHoriz,timesCalled){\r\n  const yStart = this.state.startY;\r\n  const xStart = this.state.startX;\r\n  const endY = this.state.endY;\r\n  const endX = this.state.endX;\r\n  const wayPointX = this.state.wayPointX;\r\n  const wayPointY = this.state.wayPointY;\r\n\r\n  let count = 0;\r\n  let wy = Math.ceil((height / 4) - 1); //Height is now equal to 10\r\n  let px = 0;\r\n  let height1 = 10;\r\n  while(wy < (height - 1)){ // will divide total quadrants evenly\r\n  px = x + Math.floor(Math.random() * (height - 2)) + 1; //Choose a random opening\r\n  if((px % 2) == 1){ //opening must be even, so a wall cannot accidently block the opening\r\n    px +=1;\r\n  }\r\n  for(let j = x; j < (width + x); j++){ //Iterate through creating horizontal walls\r\n    grid[wy][j] = 1;\r\n  }\r\n  grid[wy][px] = 0;\r\n  isHoriz = false;\r\n  wy += 10;\r\n  grid[yStart][xStart] = 3; //The start does not change\r\n  grid[endY][endX] = 4; //The destination does not chnage\r\n  if(this.state.wayPointAdded){\r\n    grid[wayPointY][wayPointX] = 8;\r\n  }\r\n  this.setState({\r\n    squares: grid,\r\n  });\r\n  count = this.recursiveDivision(grid,x,y,width,height1, isHoriz, count); //Upper quadrant to be divided by vert line, A horizontal section to be made into a maze\r\n\r\n  y+=10;\r\n}\r\n  y -= 1; // decrement by 1 since qudrants are not evenly divided.\r\n  this.recursiveDivision(grid,x,y,width,height1, isHoriz, count); //Last horizontal quadrant to be made into a maze\r\n}\r\n  basicRandMaze(squares,width,height){\r\n  let temp = 0;\r\n  for(let x = 0; x < height; x++){\r\n    for(let i = 0; i < width; i++){\r\n      temp = Math.floor(Math.random() * 7);\r\n      if(temp === 1 || temp === 5){\r\n      squares[x][i] = 1; // set some percentage of the grid to be a wall\r\n    }\r\n  }\r\n}\r\nconst yStart = this.state.startY;\r\nconst xStart = this.state.startX;\r\nconst endY = this.state.endY;\r\nconst endX = this.state.endX;\r\nconst wayPointAdded = this.state.wayPointAdded;\r\nconst wayPointY = this.state.wayPointY;\r\nconst wayPointX = this.state.wayPointX;\r\nif(wayPointAdded){\r\n  squares[wayPointY][wayPointX] = 8; //reset middle point if it got deleted.\r\n}\r\nsquares[yStart][xStart] = 3; //make sure start point did not get deleted\r\nsquares[endY][endX] = 4; //make sure end point did not get deleted\r\nthis.setState({\r\n  squares: squares,\r\n});\r\n}\r\n  basicWeightMaze(squares,width,height){\r\n  let temp = 0;\r\n  for(let x = 1; x < height - 1; x++){\r\n    for(let i = 1; i < width - 1; i++){\r\n      temp = Math.floor(Math.random() * 7);\r\n      if(temp === 1 || temp === 5){\r\n      squares[x][i] = 2; //Set some percentage of the maze to be equal to a bomb\r\n    }\r\n  }\r\n}\r\nconst yStart = this.state.startY;\r\nconst xStart = this.state.startX;\r\nconst endY = this.state.endY;\r\nconst endX = this.state.endX;\r\nconst wayPointAdded = this.state.wayPointAdded;\r\nconst wayPointY = this.state.wayPointY;\r\nconst wayPointX = this.state.wayPointX;\r\nif(wayPointAdded){\r\n  squares[wayPointY][wayPointX] = 8; //reset middle point if it got deleted.\r\n}\r\nsquares[yStart][xStart] = 3;\r\nsquares[endY][endX] = 4;\r\nthis.setState({\r\n  squares: squares,\r\n});\r\n}\r\n  simpleStairPattern(grid, width,height){\r\nlet x = 0\r\nlet y = height - 1; // start off at the bottom left corner of the grid\r\nlet flag = -1; //Whether we should increment or decrement the rows\r\n  while(x < width - 2){\r\n    grid[y][x] = 1; //if value is visited, set its value to 1\r\n\r\n    if(y === 2 && flag === -1){ // it has reached the top, change directions\r\n      flag = 1;\r\n    }\r\n    if(y === (height - 3) && flag === 1){ // it has reached the bottom, change directions\r\n      flag = -1;\r\n    }\r\n    x += 1;\r\n    y += flag;\r\n  }\r\n  const yStart = this.state.startY;\r\n  const xStart = this.state.startX;\r\n  const endY = this.state.endY;\r\n  const endX = this.state.endX;\r\n  const wayPointY = this.state.wayPointY;\r\n  const wayPointX = this.state.wayPointX;\r\n  const wayPointAdded = this.state.wayPointAdded;\r\n  if(wayPointAdded){\r\n    grid[wayPointY][wayPointX] = 8; //reset middle point if it got deleted.\r\n  }\r\n  grid[yStart][xStart] = 3;\r\n  grid[endY][endX] = 4;\r\nthis.setState({\r\n  squares: grid,\r\n});\r\n}\r\n  timeoutTrigger(tempGrid,currentX,currentY,val){\r\n    const wayPointAdded = this.state.wayPointAdded;\r\n    if(val === 0 && currentX === 0){\r\n      return; //do not create an opening on the border\r\n    }\r\n    if(tempGrid[currentY][currentX] === 3){\r\n      return;\r\n    }\r\n    const squares = this.state.squares.slice();\r\n    if(val === 1 && wayPointAdded && squares[currentY][currentX] === 8){ // do not draw over waypoint with a maze wall\r\n      return;\r\n    }\r\n\r\n  if(squares[currentY][currentX] !== 7){\r\n  tempGrid[currentY][currentX] = val;\r\n  this.setState({\r\n      squares: tempGrid,\r\n    });\r\n    }\r\n  }\r\n  handleClick(i,j) {\r\n    var squares = this.state.squares.slice();\r\n\r\n    squares[i][j] = squares[i][j] ? 0 : 1;\r\n\r\n\r\n    this.setState({\r\n      squares: squares,\r\n    });\r\n  }\r\n  handleMouseDownSquare(i,j){\r\n  const startY = this.state.startY;\r\n  const startX = this.state.startX;\r\n  const endY = this.state.endY;\r\n  const endX = this.state.endX;\r\n  const wayPointAdded = this.state.wayPointAdded;\r\n  const wayPointX = this.state.wayPointX;\r\n  const wayPointY = this.state.wayPointY;\r\n  let prevNodesPoint = [i, j, 0]; //If you are about to drag an icon set prevNodesPoint to its first location\r\n  this.setState({\r\n    prevNodesPoint: prevNodesPoint\r\n  });\r\n\r\n\r\n  if(i === startY && j === startX){\r\n    this.setState({\r\n      dragStart: true,\r\n    });\r\n  }\r\n  else if(i === endY && j === endX){\r\n    let prevNodesPoint = [i,j,0]\r\n    this.setState({\r\n      dragEnd: true\r\n    });\r\n  }\r\n  else if(wayPointAdded && i === wayPointY && j === wayPointX){\r\n    this.setState({\r\n      dragWayPoint: true\r\n    });\r\n  }\r\n}\r\n  handleMouseUpSquare(i,j){}\r\n  handleMouseDown(){\r\n  let isMouseDown = this.state.isMouseDown;\r\n  if(!isMouseDown){\r\n    isMouseDown = true;\r\n    this.setState({\r\n      isMouseDown: isMouseDown,\r\n    });\r\n  }\r\n  }\r\n  handleMouseUp(){\r\n  let isMouseDown = this.state.isMouseDown;\r\n  if(isMouseDown){\r\n    isMouseDown = false;\r\n    this.setState({\r\n      isMouseDown: isMouseDown,\r\n    });\r\n  }\r\n  }\r\n  handleMouseEnter(i,j){\r\n\r\n  const isMouseDown = this.state.isMouseDown;\r\n  if(!isMouseDown){\r\n    if(this.state.dragStart || this.state.dragEnd || this.state.dragWayPoint){\r\n      this.setState({\r\n        dragStart: false,\r\n        dragEnd: false,\r\n        dragWayPoint: false,\r\n        prevNodesPoint: []\r\n        });\r\n      }\r\n    return;\r\n  }\r\n  let yStart = this.state.startY;\r\n  let xStart = this.state.startX;\r\n  let endY = this.state.endY;\r\n  let endX = this.state.endX;\r\n  const wayPointY = this.state.wayPointY;\r\n  const wayPointX = this.state.wayPointX;\r\n  const isWayPointAdded = this.state.wayPointAdded;\r\n  const algorithmRunning = this.state.algorithmRunning;\r\n  var squares = this.state.squares.slice();\r\n  let prevNodesPoint = this.state.prevNodesPoint.slice() //if you are dragging an icon, this is the previous spot it was in\r\n    if(!this.state.dragStart && !this.state.dragEnd && !this.state.dragWayPoint){ //if mouse dragged in empty square or maze wall\r\n      if(squares[i][j] !== 3 && squares[i][j] !== 4 && squares[i][j] !== 8){\r\n        squares[i][j] = (squares[i][j] === 1) ? 0 : 1;\r\n        //console.log(\"X,Y coordinates: \", i,\" \",j);\r\n        this.setState({\r\n          squares: squares,\r\n        });\r\n      }\r\n    }\r\n    else if(this.state.dragStart && !this.state.dragEnd && !this.state.dragWayPoint){\r\n      if(squares[i][j] !== 4 && squares[i][j] !== 8){ //if mouse is dragging start\r\n        let arr = [i,j,squares[i][j]];\r\n        squares[i][j] = 3; //set new start point\r\n        squares[yStart][xStart] = 0; //set old start point to zero\r\n        this.setState({\r\n          squares: squares,\r\n          startY: i,\r\n          startX: j,\r\n          prevNodesPoint: arr,\r\n          });\r\n\r\n        if(algorithmRunning){//udpate the searchSpace and optimal path found when start,waypoint, or end is dragged and moved\r\n          this.handleClearPathClick(algorithmRunning);\r\n          if(isWayPointAdded){\r\n            this.aStarAlgorithm(squares, i, j, wayPointY, wayPointX, 0); //parameter Algochoice changes subfunction to Dijikstra's Algorithm. cost = pathCost instead of cost= distance from goal + pathCost\r\n            i = wayPointY;\r\n            j = wayPointX;\r\n            }\r\n          this.aStarAlgorithm(squares, i, j, endY, endX, 0); //parameter Algochoice changes subfunction to Dijikstra's Algorithm. cost = pathCost instead of cost= distance from goal + pathCost\r\n          }\r\n        }\r\n      }\r\n      else if(!this.state.dragStart && this.state.dragEnd && !this.state.dragWayPoint){\r\n        if(squares[i][j] != 3 && squares[i][j] !== 8){ //if mouse is dragging end point\r\n          let arr = [i,j,squares[i][j]];\r\n          squares[i][j] = 4; //set new ending point\r\n          squares[endY][endX] = 0; //set old ending point back to zero\r\n          this.setState({\r\n            squares: squares,\r\n            endY: i,\r\n            endX: j,\r\n            prevNodesPoint: arr,\r\n            });\r\n\r\n            if(algorithmRunning){//udpate the searchSpace and optimal path found when start,waypoint, or end is dragged and moved\r\n              this.handleClearPathClick(algorithmRunning);\r\n              if(isWayPointAdded){\r\n                this.aStarAlgorithm(squares, yStart, xStart, wayPointY, wayPointX, 0); //parameter Algochoice changes subfunction to Dijikstra's Algorithm. cost = pathCost instead of cost= distance from goal + pathCost\r\n                yStart = wayPointY;\r\n                xStart = wayPointX;\r\n                }\r\n              this.aStarAlgorithm(squares, yStart, xStart, i, j, 0); //parameter Algochoice changes subfunction to Dijikstra's Algorithm. cost = pathCost instead of cost= distance from goal + pathCost\r\n              }\r\n        }\r\n      }\r\n      else if(!this.state.dragStart && !this.state.dragEnd && this.state.dragWayPoint){\r\n        if(squares[i][j] != 3 && squares[i][j] !== 4){\r\n          let arr = [i,j,squares[i][j]];\r\n          squares[i][j] = 8; //set new waypoint\r\n          squares[wayPointY][wayPointX] = 0; //set old ending point back to zero\r\n          this.setState({\r\n            squares: squares,\r\n            wayPointY: i,\r\n            wayPointX: j,\r\n            prevNodesPoint: arr,\r\n            });\r\n\r\n            if(algorithmRunning){ //udpate the searchSpace and optimal path found when start,waypoint, or end is dragged and moved\r\n              this.handleClearPathClick(algorithmRunning);\r\n              if(isWayPointAdded){\r\n                this.aStarAlgorithm(squares, yStart, xStart, i, j, 0); //parameter Algochoice changes subfunction to Dijikstra's Algorithm. cost = pathCost instead of cost= distance from goal + pathCost\r\n                //yStart = wayPointY;\r\n                //xStart = wayPointX;\r\n                }\r\n              this.aStarAlgorithm(squares, i, j, endY, endX, 0); //parameter Algochoice changes subfunction to Dijikstra's Algorithm. cost = pathCost instead of cost= distance from goal + pathCost\r\n              }\r\n        }\r\n      }\r\n      if(prevNodesPoint.length !== 0){\r\n        squares[prevNodesPoint[0]][prevNodesPoint[1]] = prevNodesPoint[2]; //reset the previous place the icon was at to the value it was originally. I.E empty square or maze wall, or fire icon, etc\r\n        this.setState({squares:squares});\r\n      }\r\n\r\n  }\r\n  handleAlgorithmClick(i){\r\n    let algoChoice = this.state.algoChoice;\r\n    switch(i){\r\n      case \"A* Search\":\r\n        algoChoice = \"A*\";\r\n        break;\r\n\r\n      case \"Dijikstra's Algorithm\":\r\n        algoChoice = \"Dijikstra's\";\r\n        break;\r\n\r\n      case \"Greedy Best-first Search\":\r\n        algoChoice = \"Greedy\";\r\n        break;\r\n\r\n      case \"Swarm Algorithm\":\r\n        algoChoice = \"Swarm\";\r\n        break;\r\n\r\n      case \"Convergent Swarm Algorithm\":\r\n        algoChoice = \"Convergent Swarm\";\r\n        break;\r\n\r\n      case \"Bidirectional Swarm Algorithm\":\r\n      algoChoice = \"Bidirectional Swarm\";\r\n      break;\r\n\r\n      case \"Breadth-first Search\":\r\n      algoChoice = \"BFS\";\r\n      break;\r\n\r\n      case \"Depth-first Search\":\r\n      algoChoice = \"DFS\";\r\n      break;\r\n    }\r\n    this.setState({\r\n      algoChoice: algoChoice,\r\n    });\r\n\r\n\r\n\r\n  }\r\n  handleMazes_PatternsClick(i){\r\n    let squares = this.state.squares.slice();\r\n    const width = this.state.width;\r\n    const height = this.state.height;\r\n    var orientation = false;\r\n    this.setState({algorithmRunning: false});\r\n    //let mazeChoice = \"\"\r\n    for(let x = 0; x < height; x++){\r\n      for(let i = 0; i < width; i++){\r\n      squares[x][i] = 0; //Reset the maze to be empty before calling recursiveDivision function\r\n    }\r\n  }\r\n    switch(i){\r\n      case \"Recursive Division\":\r\n      this.createMazeBorder(width);\r\n      squares = this.state.squares.slice();\r\n\r\n        orientation = false;\r\n        this.recursiveDivision(squares,0,0,width,height,orientation,0,0);\r\n\r\n        //mazeChoice = \"Recursive Division\";\r\n        break;\r\n\r\n      case \"Recursive Division (vertical skew)\":\r\n        this.createMazeBorder(width);\r\n        squares = this.state.squares.slice();\r\n        this.recursiveDivisionVertSkew(squares,0,0,width,height,orientation,0);\r\n\r\n        //mazeChoice = \"Recursive Division (vertical skew)\";\r\n        break;\r\n\r\n      case \"Recursive Division (horizontal skew)\":\r\n        this.createMazeBorder(width);\r\n        squares = this.state.squares.slice();\r\n        this.recursiveDivisionHorizSkew(squares,0,0,width,height,orientation,0);\r\n\r\n        //mazeChoice = \"Recursive Division (horizontal skew)\";\r\n        break;\r\n\r\n      case \"Basic Random Maze\":\r\n        this.createMazeBorder(width);\r\n        squares = this.state.squares.slice();\r\n        this.basicRandMaze(squares,width,height);\r\n        //mazeChoice = \"Basic Random Maze\";\r\n        break;\r\n\r\n      case \"Basic Weight Maze\":\r\n        this.createMazeBorder(width);\r\n        squares = this.state.squares.slice();\r\n        this.basicWeightMaze(squares,width,height);\r\n        //mazeChoice = \"Basic Weight Maze\";\r\n        break;\r\n\r\n      case \"Simple Stair Pattern\":\r\n      this.createMazeBorder(width);\r\n      squares = this.state.squares.slice();\r\n      this.simpleStairPattern(squares, width,height);\r\n      //mazeChoice = \"Simple Stair Pattern\";\r\n      break;\r\n      case \"Create Border\":\r\n      this.createMazeBorder(width);\r\n      break;\r\n\r\n  }\r\n}\r\n  handleAddBombClick(){\r\n    let squares = this.state.squares.slice();\r\n    let wayPointX = this.state.wayPointX;\r\n    let wayPointY = this.state.wayPointY;\r\n    let wayPointAdded = true;\r\n    squares[wayPointY][wayPointX] = 8;\r\n    this.setState({\r\n      squares:squares,\r\n      wayPointAdded: wayPointAdded\r\n    });\r\n  }\r\n  visualizeAlgorithmsAnimation(grid,optimalPath, searchSpace, val, count){\r\n    //let count = 0;\r\n    let currentX;\r\n    let currentY;\r\n    let coords = [];\r\n    const algorithmRunning = this.state.algorithmRunning;\r\n    const width = this.state.width;\r\n    const height = this.state.height;\r\n    const speed = this.state.speed;\r\n    const squares = this.state.squares.slice();\r\n    this.setState({\r\n      spaceSearched: searchSpace,\r\n      optimalPath: optimalPath\r\n      });\r\n\r\n    for(let i = 1; i < searchSpace.length; i++){\r\n      currentY = searchSpace[i][0];\r\n      currentX = searchSpace[i][1];\r\n      count += 1;\r\n      if(algorithmRunning){\r\n        if(grid[currentY][currentX] !== 7){\r\n        grid[currentY][currentX] = val; //set search space all at one time\r\n        }\r\n      }\r\n      else{\r\n        setTimeout(this.timeoutTrigger.bind(this), speed * count,grid,currentX,currentY,val); //delay css animation\r\n      } //val is 6 i.e space searched\r\n\r\n    }\r\n    val = 7; //Val is 7 for highlighting optimal path found\r\n\r\n    if(optimalPath !== 0){\r\n      let i = (this.state.wayPointAdded) ? 0 : 1; //if middle point added start optimal path from very beginning, else start offset by 1\r\n      //this.setState({optimalPath: optimalPath});\r\n      val = 7; //Val is 7 for highlighting optimal path found\r\n      for(i; i < optimalPath.length - 1; i++){\r\n        coords = getX_Y(optimalPath[i],width,height);\r\n        count += 1;\r\n        currentY = coords[0];\r\n        currentX = coords[1];\r\n        if(algorithmRunning){\r\n\r\n          grid[currentY][currentX] = val; //set path all at one time\r\n        }\r\n        else{\r\n        setTimeout(this.timeoutTrigger.bind(this), speed * count,grid,currentX,currentY,val); //delay css animation\r\n        }\r\n      }\r\n    if(algorithmRunning){\r\n      this.setState({squares: grid});\r\n      }\r\n\r\n    return count;\r\n    }\r\n  }\r\n  aStarAlgorithm(grid,startY,startX,endY, endX, count){\r\n    const algoChoice = this.state.algoChoice;\r\n    const speed = this.state.speed;\r\n    let width = this.state.width;\r\n    let height = this.state.height;\r\n    let wayPointX = this.state.wayPointX;\r\n    let wayPointY = this.state.wayPointY;\r\n    let wayPointAdded = this.state.wayPointAdded;\r\n    const algorithmRunning = this.state.algorithmRunning;\r\n    let tempEndX = endX;\r\n    let tempEndY = endY;\r\n    let currentX = startX; //current node x coord to be explored\r\n    let currentY = startY; //current node y coord to be explored\r\n    let pathCost = 1; //number of nodes traversed\r\n    let minCost = 999999; // set to high minimum cost\r\n    let costNorth = 0, costEast = 0, costSouth = 0, costWest = 0;\r\n    let visitedNodes = new Map([]); //if node has been visited\r\n    let expandNodes = new Map([]); // key will be cost of node, when collisions add to end of array at that key, value will be key of visitedNodes\r\n    let tempCost = Math.abs(endY - startY) + Math.abs(endX - startX); //Heuristic + 0, where 0 is cost of path\r\n    let expandNodesCost = [tempCost]; //expandNodesCost.sort(compare()); A list of of all nodes costs sorted\r\n    let foundGoal = false;\r\n    let moreNodesToExpand = true;\r\n    let tempKey = getKey(startY,startX,width,height);// Parameters: row, column, width, height\r\n    let tempPath = [tempKey]; //list of nodes that form a path\r\n    let fireCost = 0;\r\n    let tempValue = [tempCost,tempPath,fireCost]\r\n    let currentValue = [tempCost,tempPath];\r\n    let goalKey = getKey(endY,endX,width,height); // where the goal is located\r\n    visitedNodes.set(tempKey,tempValue);\r\n    let returnCurrentCoords = [];\r\n    let listOfKeys = [tempKey];\r\n    expandNodes.set(tempCost,listOfKeys); //set key to be the cost, and the value to be the key of the next node to be deciphered. Use key to get X, Y coords.\r\n    let smallestCost = 9999;\r\n    let val = 6;\r\n    let optimalPath = []; //Optimal path to destination\r\n    let coords = []; //coords in optimal path\r\n    let searchSpace = [];\r\n    let totalOptimalPath = [];\r\n    let pastWayPoint = (wayPointAdded) ? false: true; //if made it past way point\r\n    let fireIcon = false;\r\n    var iterateExpandNodes = [];\r\n    var space = new Map();\r\n    while(!foundGoal && moreNodesToExpand){\r\n      fireIcon = false;\r\n      //Here we choose which node to expand\r\n      //console.log(\"Array: \", expandNodesCost);\r\n      if(algoChoice === \"DFS\" ){\r\n        smallestCost = expandNodesCost.pop(); //simultaneously removes and returns the last index of the array for Depth First Search\r\n\r\n      }\r\n      else{\r\n        smallestCost = expandNodesCost.shift(); //simultaneously removes and returns the first index of the array\r\n      }\r\n\r\n      listOfKeys = expandNodes.get(smallestCost);// get nodes with the smallest cost\r\n      tempKey = listOfKeys.shift();\r\n      if(space.has(tempKey)){\r\n        continue; //if the value has been visited already go ahead and skip it\r\n      }\r\n      else{\r\n        space.set(tempKey,0); //add the key to visited list\r\n      }\r\n      returnCurrentCoords = getX_Y(tempKey,width,height);\r\n      currentY = returnCurrentCoords[0];\r\n      currentX = returnCurrentCoords[1];\r\n      searchSpace.push(returnCurrentCoords.slice()); //list of space searched\r\n\r\n      currentValue = visitedNodes.get(tempKey).slice(); // return the current cost and value\r\n\r\n      pathCost = currentValue[1].length + (currentValue[2] * 14); // If there are fire icons the cost is added\r\n      //pathCost = currentValue[0];\r\n      //console.log(\"Path cost: \", pathCost);\r\n      //console.log(\"Fire cost: \", currentValue[2]);\r\n      if((currentX + 1 === endX && currentY === endY) ||(currentX - 1 === endX && currentY === endY) || (currentX === endX && currentY - 1 === endY) || (currentX === endX && currentY + 1 === endY)){\r\n\r\n          foundGoal = true;\r\n          optimalPath = visitedNodes.get(tempKey).slice();\r\n          optimalPath[1].push(goalKey);\r\n          if(wayPointAdded){\r\n            optimalPath[1].shift(); //remove the start index from the optimal path, so it does not become obscured by css animations and colors\r\n          }\r\n          totalOptimalPath.push.apply(totalOptimalPath,optimalPath[1]);\r\n\r\n      }\r\n\r\n\r\n      if(currentX + 1 < width && (grid[currentY][currentX + 1] === 0 || grid[currentY][currentX + 1] === 2 || grid[currentY][currentX + 1] === 7 || (algorithmRunning && grid[currentY][currentX + 1] === 6) ) ) {\r\n        /*TURN EVERYTHING INSIDE THIS IF/ELSE STATEMENT INTO A FUNCTION.*/\r\n        if(grid[currentY][currentX + 1] === 2){\r\n          pathCost += 14;\r\n          fireIcon = true;\r\n        }\r\n        else{\r\n          fireIcon = false;\r\n        }\r\n        frontierNodes(currentY,currentX,endY,endX,pathCost,width,height,tempKey,visitedNodes,foundGoal,tempValue,currentValue,expandNodesCost,expandNodes,1,0,algoChoice,startY,startX,fireIcon);\r\n      }\r\n      if(currentX - 1 >= 0 && (grid[currentY][currentX - 1] === 0 || grid[currentY][currentX - 1] === 2  || grid[currentY][currentX - 1] === 7  || (algorithmRunning && grid[currentY][currentX - 1] === 6))){\r\n        if(grid[currentY][currentX - 1] === 2){\r\n          pathCost += 14;\r\n          fireIcon = true;\r\n        }\r\n        else{\r\n          fireIcon = false;\r\n        }\r\n        frontierNodes(currentY,currentX,endY,endX,pathCost,width,height,tempKey,visitedNodes,foundGoal,tempValue,currentValue,expandNodesCost,expandNodes,-1,0,algoChoice,startY,startX,fireIcon);\r\n      }\r\n      if(currentY - 1 >= 0 && (grid[currentY - 1][currentX] === 0 || grid[currentY - 1][currentX] === 2 || grid[currentY - 1][currentX] === 7 || (algorithmRunning && grid[currentY - 1][currentX] === 6))){\r\n        if(grid[currentY - 1][currentX] === 2){\r\n          pathCost += 14;\r\n          fireIcon = true;\r\n        }\r\n        else{\r\n          fireIcon = false;\r\n        }\r\n        frontierNodes(currentY,currentX,endY,endX,pathCost,width,height,tempKey,visitedNodes,foundGoal,tempValue,currentValue,expandNodesCost,expandNodes,0,-1,algoChoice,startY,startX,fireIcon);\r\n      }\r\n      if(currentY + 1 < height && (grid[currentY + 1][currentX] === 0 || grid[currentY + 1][currentX] === 2 || grid[currentY + 1][currentX] === 7 || (algorithmRunning && grid[currentY + 1][currentX] === 6))){\r\n        if(grid[currentY + 1][currentX] === 2){\r\n          pathCost += 14;\r\n          fireIcon = true;\r\n        }\r\n        else{\r\n          fireIcon = false;\r\n        }\r\n        frontierNodes(currentY,currentX,endY,endX,pathCost,width,height,tempKey,visitedNodes,foundGoal,tempValue,currentValue,expandNodesCost,expandNodes,0,1,algoChoice,startY,startX,fireIcon);\r\n      }\r\n\r\n      //At the end remove currentX and currentY from expandNodes, expandNodesCost. Update foundGoal and mroeNodesToExpand booleans.\r\n      tempKey = getKey(currentY,currentX, width, height);\r\n      tempValue = visitedNodes.get(tempKey).slice();\r\n\r\n      moreNodesToExpand = (expandNodesCost.length === 0) ? false: true; //if list is empty then the algorithm has searched everything\r\n\r\n    }\r\n\r\n  if(foundGoal){\r\n    count = this.visualizeAlgorithmsAnimation(grid,totalOptimalPath,searchSpace, 6, count); //6 is for settting the search space squares to blue\r\n  } else{\r\n    count = this.visualizeAlgorithmsAnimation(grid,0, searchSpace, 6, count); //No path to goal is found, so optimalPath is equal to zero\r\n  }\r\n  return count;\r\n}\r\n  handleVisualizeAlgorithmClick(){\r\n    let startY = this.state.startY;\r\n    let startX = this.state.startX;\r\n    let endY = this.state.endY;\r\n    let endX = this.state.endX;\r\n    let wayPointX = this.state.wayPointX;\r\n    let wayPointY = this.state.wayPointY;\r\n    let wayPointAdded = this.state.wayPointAdded;\r\n    let algoChoice = this.state.algoChoice;\r\n    let grid = this.state.squares.slice();\r\n    let count = 0;\r\n\r\n    switch(algoChoice){\r\n      case \"A*\":\r\n        if(wayPointAdded){\r\n        count = this.aStarAlgorithm(grid, startY, startX, wayPointY, wayPointX, count); //parameter Algochoice changes subfunction to Dijikstra's Algorithm. cost = pathCost instead of cost= distance from goal + pathCost\r\n        startY = wayPointY;\r\n        startX = wayPointX;\r\n      }\r\n        this.aStarAlgorithm(grid, startY, startX, endY, endX, count); //parameter Algochoice changes subfunction to Dijikstra's Algorithm. cost = pathCost instead of cost= distance from goal + pathCost\r\n        break;\r\n\r\n      case \"Dijikstra's\":\r\n        if(wayPointAdded){\r\n          count = this.aStarAlgorithm(grid, startY, startX, wayPointY, wayPointX, count);\r\n          startY = wayPointY;\r\n          startX = wayPointX;\r\n        }\r\n        this.aStarAlgorithm(grid, startY, startX, endY, endX, count); //parameter Algochoice changes subfunction to Dijikstra's Algorithm. cost = pathCost instead of cost= distance from goal + pathCost\r\n        break;\r\n\r\n      case \"Greedy\":\r\n        if(wayPointAdded){\r\n          count = this.aStarAlgorithm(grid, startY, startX, wayPointY, wayPointX, count);\r\n          startY = wayPointY;\r\n          startX = wayPointX;\r\n        }\r\n        this.aStarAlgorithm(grid, startY, startX, endY, endX, count); //parameter Algochoice changes subfunction to Greedy Best Algorithm. cost = distance from goal\r\n        break;\r\n\r\n      case \"Swarm\":\r\n\r\n        break;\r\n\r\n      case \"Convergent Swarm\":\r\n\r\n        break;\r\n\r\n      case \"Bidirectional Swarm\":\r\n\r\n      break;\r\n\r\n      case \"BFS\":\r\n        if(wayPointAdded){\r\n          count = this.aStarAlgorithm(grid, startY, startX, wayPointY, wayPointX, count);\r\n          startY = wayPointY;\r\n          startX = wayPointX;\r\n        }\r\n        this.aStarAlgorithm(grid, startY, startX, endY, endX, count); //parameter Algochoice changes subfunction to BFS. Cost Function is always zero.\r\n      break;\r\n\r\n      case \"DFS\":\r\n        if(wayPointAdded){\r\n          count = this.aStarAlgorithm(grid, startY, startX, wayPointY, wayPointX, count);\r\n          startY = wayPointY;\r\n          startX = wayPointX;\r\n        }\r\n        this.aStarAlgorithm(grid, startY, startX, endY, endX, count); //parameter Algochoice changes subfunction to BFS. Cost Function is always zero.\r\n      break;\r\n    }\r\n    this.setState({algorithmRunning: true});\r\n  }\r\n  handleClearBoardClick(){\r\n    const width = this.state.width;\r\n    const height = this.state.height;\r\n    const startX = this.state.defaultStartX;\r\n    const startY = this.state.defaultStartY;\r\n    const endX = this.state.defaultEndX;\r\n    const endY = this.state.defaultEndY;\r\n    const wayPointX = this.state.defaultWayPointX;\r\n    const wayPointY = this.state.defaultWayPointY;\r\n    let x = Array(height).fill(null);\r\n    for(let i = 0; i < height; i++){\r\n      x[i] = Array(width).fill(0);\r\n    }\r\n    x[startY][startX] = 3;\r\n    x[endY][endX] = 4;\r\n    this.setState({\r\n      squares: x,\r\n      startY: startY,\r\n      startX: startX,\r\n      endY: endY,\r\n      endX: endX,\r\n      wayPointX: wayPointX,\r\n      wayPointY: wayPointY,\r\n      wayPointAdded: false,\r\n      algorithmRunning: false\r\n    });\r\n  }\r\n  handleClearWalls_WeightsClick(){\r\n    const width = this.state.width;\r\n    const height = this.state.height;\r\n    const startX = this.state.startX;\r\n    const startY = this.state.startY;\r\n    const endX = this.state.endX;\r\n    const endY = this.state.endY;\r\n    const wayPointY = this.state.wayPointY;\r\n    const wayPointX = this.state.wayPointX;\r\n    let x = Array(height).fill(null);\r\n    for(let i = 0; i < height; i++){ //initiliaze an empty array\r\n      x[i] = Array(width).fill(0);\r\n    }\r\n    if(this.state.wayPointAdded){\r\n      x[wayPointY][wayPointX] = 8;\r\n    }\r\n    x[startY][startX] = 3;\r\n    x[endY][endX] = 4;\r\n    this.setState({\r\n      squares: x,\r\n      algorithmRunning: false\r\n    });\r\n  }\r\n  handleClearPathClick(isAlgorithmRunning){\r\n    //let spaceSearched = this.state.spaceSearched.slice();\r\n  //  let optimalPath = this.state.optimalPath.slice();\r\n    let grid = this.state.squares.slice();\r\n    let startY = this.state.startY;\r\n    let startX = this.state.startX;\r\n    let endY = this.state.endY;\r\n    let endX = this.state.endX;\r\n    const width = this.state.width;\r\n    const height = this.state.height;\r\n    for(let i = 0; i < height; i++){\r\n      for(let j = 0; j < width; j++){\r\n        if(grid[i][j] === 6 || grid[i][j] === 7){\r\n            grid[i][j] = 0; //reset search routes and path to empty squares\r\n            }\r\n          }\r\n        }\r\n\r\n    grid[startY][startX] = 3;\r\n    grid[endY][endX] = 4;\r\n    this.setState({\r\n      squares: grid,\r\n    });\r\n    if(!isAlgorithmRunning){\r\n      this.setState({algorithmRunning: false})\r\n    }\r\n\r\n  }\r\n  handleSpeedClick(i){\r\n    let speed = this.state.speed;\r\n    let speedName = this.state.speedName;\r\n    if(i === \"Fast\"){\r\n      speed = 25;\r\n      speedName = \"Fast\";\r\n    }\r\n    if(i === \"Average\"){\r\n      speed = 50;\r\n      speedName = \"Average\";\r\n    }\r\n    if(i === \"Slow\"){\r\n      speed = 100;\r\n      speedName = \"Slow\";\r\n    }\r\n    this.setState({\r\n      speed: speed,\r\n      speedName: speedName,\r\n    });\r\n  }\r\n\r\n\r\n  render() {\r\n    const squares = this.state.squares;\r\n    const algoChoice = this.state.algoChoice;\r\n    const width = this.state.width;\r\n    const height = this.state.height;\r\n    const speedName = this.state.speedName;\r\n    return (\r\n\r\n\r\n        <div>\r\n        <ul>\r\n          <h4 className =\"title\">Pathfinding Visualizer</h4>\r\n          <Algorithms\r\n            onClick = {this.handleAlgorithmClick}\r\n            />\r\n          <Mazes_Patterns\r\n            onClick = {this.handleMazes_PatternsClick}/>\r\n          <Bombs\r\n            onClick = {this.handleAddBombClick}/>\r\n          <VisualizeAlgorithm\r\n            onClick = {this.handleVisualizeAlgorithmClick}\r\n            algoChoice = {algoChoice}/>\r\n          <ClearBoard\r\n            onClick = {this.handleClearBoardClick}/>\r\n          <ClearWalls_Weights\r\n            onClick = {this.handleClearWalls_WeightsClick}/>\r\n          <ClearPath\r\n            onClick = {this.handleClearPathClick}/>\r\n          <SpeedOfAlgorithm\r\n            speedName = {speedName}\r\n            onClick = {this.handleSpeedClick}/>\r\n          <Tutorial/>\r\n        </ul>\r\n          <div>\r\n\r\n            <div className = \"flex-container\">\r\n            <div >Starting Point <FontAwesomeIcon className = \"leftPadding fa-2x blackIcon\"icon={faRocket} /> </div>\r\n            <div>Waypoint  <FontAwesomeIcon className = \"leftPadding fa-2x greenMoney\"icon={faMoneyBill} /> </div>\r\n            <div>Destination  <FontAwesomeIcon className = \"leftPadding fa-2x blackIcon\"icon={faGlobeAmericas} /> </div>\r\n            <div>Maze wall<div className = \"blueVis visualSquare\"></div></div>\r\n            <div>Space Searched<div className = \"searchVis visualSquare\"></div></div>\r\n            <div>Path to destination <div className = \"orangeVis visualSquare\"></div></div>\r\n            <div>+15 Path cost<FontAwesomeIcon  className = \"leftPadding iconsFire fa-2x\" icon={faFire} /></div>\r\n            </div>\r\n\r\n            </div>\r\n          <div className = \"fill-height\" onMouseDown = {this.handleMouseDown} onMouseUp = {this.handleMouseUp}>\r\n          <Board\r\n            width = {width}\r\n            height = {height}\r\n            squares = {squares}\r\n            onClick = {this.handleClick}\r\n            onMouseEnter = {this.handleMouseEnter}\r\n            onMouseDown = {this.handleMouseDownSquare}\r\n          />\r\n          </div>\r\n        </div>\r\n\r\n    );\r\n  }\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(\r\n  <Game />,\r\n  document.getElementById('root')\r\n);\r\nfunction compare(a, b) {\r\n  return a > b ? 1 : b > a ? -1 : 0; //sort in ascending order\r\n}\r\nfunction getKey(row,column,width,height){\r\n  let key = (row * width) + column;\r\n  return key;\r\n}\r\nfunction getX_Y(key,width,height){\r\n  let tempY = 0;\r\n  let tempX = 0;\r\n  tempY = Math.floor(key / width); //gives the column\r\n  tempX = key % width;\r\n  let coords = [tempY,tempX];\r\n  return coords;\r\n\r\n}\r\nfunction binaryInsert(x, array) {\r\n  if(array.length === 0){\r\n    array.push(x);\r\n    return;\r\n  }\r\nvar l = 0,\r\nr = array.length - 1,\r\nm;\r\nwhile (l <= r) {\r\nm = (l + r) / 2 | 0;\r\nif (array[m] > x) {\r\nr = m - 1;\r\ncontinue;\r\n}\r\nl = m + 1;\r\nif (array[m] === x) {\r\nbreak; // replace with return if no duplicates are desired\r\n}\r\n}\r\narray.splice(l, 0, x);\r\n}\r\n\r\nfunction frontierNodes(currentY,currentX,endY,endX,pathCost,width,height,tempKey,visitedNodes,foundGoal,tempValue,currentValue,expandNodesCost,expandNodes,xFlag,yFlag,algoChoice,startY,startX,fireIcon){\r\n  //let costEast = (Math.abs(endY - currentY + yFlag)) + (Math.abs(endX - currentX + xFlag)) + pathCost; //Current straight line distance of the node from the goal node plus the number of nodes traversed to get to the current node i.e +1\r\n  let yVal = endY - (currentY + yFlag);\r\n  let xVal = endX - (currentX + xFlag);\r\n  let costEast = Math.abs(xVal) + Math.abs(yVal);\r\n  if(algoChoice === \"A*\"){\r\n  costEast += pathCost; //choice for A* Algorithm\r\n  //console.log(pathCost);\r\n}\r\nelse if(algoChoice === \"Dijikstra's\" || algoChoice === \"DFS\" ){\r\n  costEast = pathCost; //choice for dijikstra's Algorithm\r\n}\r\nelse if(algoChoice === \"Greedy\"){\r\n  costEast = costEast; //choice for Greedy. setting it equal to itself is redundant, but is there to illustrate the heuristic choice.\r\n}\r\nelse if(algoChoice === \"BFS\"){\r\n  yVal = startY - (currentY + yFlag);\r\n  xVal = startX - (currentX + xFlag);\r\n  costEast = Math.abs(xVal) + Math.abs(yVal);\r\n}\r\n  tempKey = getKey((currentY + yFlag), (currentX + xFlag), width, height);\r\n  if(visitedNodes.has(tempKey)){ //check to see if it is in visited nodes already\r\n      let oldCost_Path = visitedNodes.get(tempKey).slice(); //get the old cost and path to that node, only update the cost and path if new cost and path is cheaper\r\n      if(oldCost_Path[0] > costEast && (algoChoice === \"A*\" || algoChoice === \"Dijikstra's\")){\r\n        //First update expandNodesCost Array\r\n      //  for(let i = 0; i < expandNodesCost.length; i++){\r\n      //    if(expandNodesCost[i] === oldCost_Path[0]){\r\n        //    expandNodesCost.splice(i,1); //remove the old cost from list of costs\r\n        //    break; //break from the for loop\r\n        //  }\r\n      //  }\r\n        binaryInsert(costEast,expandNodesCost); //insert new cost sorted into list of costs. DO Not update this.\r\n\r\n        //Second update expandNode Map(costOfNode,[list of keys])\r\n        //first remove old Node from expandNodes\r\n        let listOfKeys = expandNodes.get(oldCost_Path[0]).slice();\r\n        for(let i = 0; i < listOfKeys.length; i++){\r\n          if(listOfKeys[i] === tempKey){\r\n            listOfKeys.splice(i,1); //remove the element from the array\r\n            break; //exit the for loop\r\n          }\r\n        }\r\n        //update expandNodes\r\n        if(expandNodes.has(costEast)){\r\n        listOfKeys = expandNodes.get(costEast).slice(); //get the listOfkeys for that cost.\r\n        listOfKeys.unshift(tempKey); //insert the key into the front of the list.\r\n        expandNodes.set(costEast, listOfKeys.slice()); //insert the new updated list back into the map\r\n          }\r\n          else{\r\n            let tempArr = [tempKey];\r\n            expandNodes.set(costEast, tempArr.slice());\r\n          }\r\n        //update vistedNodes\r\n        let oldTempKey = getKey(currentY, currentX, width, height);\r\n        let oldVisitedValues = visitedNodes.get(oldTempKey).slice();\r\n        let newVisitedValues = [];\r\n        newVisitedValues.push(costEast); //update with the new cost\r\n        let temp = (Array.isArray(oldVisitedValues[1])) ? oldVisitedValues[1].slice() : [oldVisitedValues[1]]; //if it is an array get a deep copy of it, else make it an array, path list\r\n        temp.push(tempKey);\r\n        newVisitedValues.push(temp.slice()); //add a deep copy of the array into the new array\r\n        newVisitedValues.push(oldVisitedValues[2]); //add in fire path costs\r\n          if(fireIcon){\r\n            newVisitedValues[2] += 1;\r\n          }\r\n        visitedNodes.set(tempKey,newVisitedValues.slice());\r\n      }\r\n  }\r\n  else{ //add node to visited list, add node to expandNodes aray and expandNodesCost map.\r\n    tempKey = getKey(currentY,currentX,width,height);\r\n    tempValue = visitedNodes.get(tempKey).slice();\r\n    let valPassed = [costEast]; //create value to be passed into visitedNodes map\r\n    let temp1 = (Array.isArray(tempValue[1])) ? tempValue[1].slice() : [tempValue[1]];\r\n    valPassed.push(temp1);\r\n    if(fireIcon){\r\n      tempValue[2] += 1;\r\n    }\r\n    valPassed.push(tempValue[2]);\r\n    //currentValue[1] = tempValue[1].slice();\r\n\r\n    tempKey = getKey(currentY + yFlag, currentX + xFlag, width, height);\r\n    valPassed[1].push(tempKey);\r\n    visitedNodes.set(tempKey,valPassed.slice());\r\n    binaryInsert(costEast,expandNodesCost); //sort the array with the added element\r\n  //  expandNodesCost.push(costEast);\r\n    //console.log(\"list of cost of each node: \",expandNodesCost);\r\n    //console.log(expandNodesCost);\r\n    if(expandNodes.has(costEast)){ //if there is already node with the same cost, add that node to the end of values array.\r\n      tempValue = expandNodes.get(costEast).slice();\r\n      tempValue.unshift(tempKey); //add to the front of the list\r\n      //tempValue.push(tempKey); //add to the end of the list\r\n      expandNodes.set(costEast,tempValue.slice());\r\n    }\r\n    else{\r\n      tempValue = [tempKey];\r\n      expandNodes.set(costEast,tempValue.slice());\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":""}